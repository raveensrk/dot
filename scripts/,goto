#!/bin/bash

# set -e

# set -x
source ~/.bash_prompt


# HELP: This script uses fzf to print all the lines of text present in
# HELP: the current directory recrusively. Then it pipes it to fzf and
# HELP: allows the user to select the text, then it opens the file in the
# HELP: default "$EDITOR" with the cursor on that line. Also allows
# HELP: multiselection. Refer fzf multi selection option. Defaults to TAB
# HELP: key.
# Help: --------------
# Help: Example Usage:
# Help: --------------
# Help: goto 
# Help: goto --help
# Help: goto --ext md
# Help: goto --ext md --input /path/to/dir

help () {
    less "$0"
}

while [ "$1" ]; do
    case "$1" in
        --input|-i)
            # HELP: --input|-i  This will get the input from the user
            shift
            input="$1"
            ;;
        --print|-p)
            # HELP: --print|-p  Will print instead of opening the file in the editor
            print="1"
            ;;
        --string|-s)
            shift
            string="$1"
            ;;
        --ext)
            # HELP: --ext  Only the extension will be filtered, example: md, org, bash, multiple --ext options allowed
            shift
            ext+=("$1")
            ;;
        --file)
            shift
            file+=("$1")
            ;;
        --file-names|-fn)
            grep_filenames_also="true"
            ;;
        --help|-h)
            # HELP: --help|help  prints help
            help
            ;;
        *)
            echo -e "${RED}❌ ERROR! WRONG Argument!${NC}"
            exit 2
            ;;
    esac
    shift
done

string=${string:-.}
print=${print:-0}

for item in "${file[@]}"; do
    include="$include --include=*$item"
done

for item  in ${ext[@]}; do
    include="$include --include=*.$item"
done
include=${include:-}

if [ "$input" != "" ]; then
    pushd "$input" || exit 2
fi

selection="/tmp/goto_selection_$$.txt"
touch "$selection"


trap clean_up INT

clean_up () {
    yellow
    echo caught ^C, removing $selection
    nc
    rm $selection
    exit
}


if [ "$include" != "" ]; then
    grep $include --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.packages -H -n -R "$string" | fzf -m -e -d : -n 3 > "$selection"
else
    # item=$(grep --exclude-dir=.git --exclude-dir=.hg -H -n -r . | fzf -e )
    if [ "$grep_filenames_also" = "true" ]; then
        rg -L -n --no-heading -. "$string" --ignore-file "$HOME/.scripts/.ignore" | fzf -m -e  > "$selection" # This will grep both file contents and name
    else
        rg -L -n --no-heading -. "$string" --ignore-file "$HOME/.scripts/.ignore" | fzf -m -e -d : -n 3 > "$selection" # This will only grep file contents
    fi
fi

if [ "$print" = "1" ]; then
    cat "$selection" | sed "s|^|$input/|;s|//|/|g"
else
    while read -r -u5 item; do
        # echo "$item"
        file=$(echo "$item" | awk -F ':' '{print $1}')
        # echo "$file"
        line=$(echo "$item" | awk -F ':' '{print $2}')
        # echo "$line"
        file_absolute_path="$file"

        echo "$EDITOR \"+$line\" \"$file_absolute_path\" "
        $EDITOR "+$line" "$file_absolute_path"
    done 5< "$selection"
fi


rm "$selection"

if [ "$input" != "" ]; then
    popd || exit 2
fi
